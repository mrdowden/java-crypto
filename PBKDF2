package org.tekyn.crypto;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.CharBuffer;
import java.nio.charset.Charset;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;

public class PBKDF2
{
  private static final Charset UTF8 = Charset.forName( "UTF-8" );
  private final String algorithm;
  private final int c;
  private final Mac prf;

  public PBKDF2(String algorithm, int iterations) {
  	this.algorithm = algorithm;
    this.prf = Mac.getInstance( algorithm );
    this.c = iterations;
  }

  public byte[] derive( char[] password, byte[] salt ) throws NoSuchAlgorithmException,
      InvalidKeyException
  {
    final byte[] pass = UTF8.encode( CharBuffer.wrap( password ) ).array();
    final SecretKeySpec keyspec = new SecretKeySpec( pass, algorithm );
    prf.init( keyspec );

    byte[] T = new byte[prf.getMacLength() * prf.getMacLength()];
    int ti_offset = 0;
    for( int i = 1; i <= prf.getMacLength(); i++ )
    {
      byte[] x = F( password, salt, c, i );
      System.arraycopy( x, 0, T, ti_offset, prf.getMacLength() );
      ti_offset += prf.getMacLength();
    }

    Arrays.fill( password, '*' );
    return T;
  }

  private byte[] F( char[] password, byte[] salt, int totalIterations, int iteration )
  {
    final byte[] initialSalt = Arrays.copyOf( salt, salt.length + 4 );
    System.arraycopy( INT( iteration ), 0, initialSalt, salt.length, 4 );
    byte[] Ux = PRF( password, initialSalt );
    byte[] result = Ux;
    for( int i = 1; i < totalIterations; i++ )
    {
      Ux = PRF( password, Ux );
      xor( result, Ux );
    }
    return result;
  }

  private byte[] PRF( char[] password, byte[] salt )
  {
    final byte[] pass = UTF8.encode( CharBuffer.wrap( password ) ).array();
    byte[] message =
        ByteBuffer.wrap( new byte[pass.length + salt.length] ).put( pass ).put( salt ).array();

    return prf.doFinal( message );
  }

  private void xor( byte[] dest, byte[] src )
  {
    for( int i = 0; i < dest.length; i++ )
    {
      dest[i] ^= src[i];
    }
  }
  
  private byte[] INT( final int value )
  {
    final ByteBuffer buffer = ByteBuffer.allocate( 4 );
    buffer.order( ByteOrder.BIG_ENDIAN );
    buffer.putInt( value );
    buffer.flip();
    return buffer.array();
  }

}
